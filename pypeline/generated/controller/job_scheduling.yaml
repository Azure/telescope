stages:
- displayName: Job Scheduling
  jobs:
  - job: setup
    displayName: Setup resources
    steps:
    - displayName: Set run id
      script: |-
        if [ -n "$RUN_ID" ]; then
            run_id=$RUN_ID
        else
            run_id=$(Build.BuildId)-$(System.JobId)
        fi
            echo "Run ID: $run_id"
            echo "##vso[task.setvariable variable=RUN_ID]$run_id"
      env:
        RUN_ID: null
    - displayName: Set Run URL & Code URL
      script: |-
        run_url="$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)&view=logs&j=$(System.JobId)"
        echo "Run URL: $run_url"
        echo "##vso[task.setvariable variable=RUN_URL]$run_url"

        code_url="$(Build.Repository.Uri)/commit/$(Build.SourceVersion)"
        echo "Code URL: $code_url"
        echo "##vso[task.setvariable variable=CODE_URL]$code_url"
    - displayName: Set Test Results Directory
      script: |-
        test_results_directory=$(Pipeline.Workspace)/s/$(RUN_ID)
        mkdir -p $test_results_directory
        echo "Test Results directory: $test_results_directory"
        echo "##vso[task.setvariable variable=TEST_RESULTS_DIR]$test_results_directory"

        test_results_file=$test_results_directory/results.json

        echo "Test Results file: $test_results_file"
        echo "##vso[task.setvariable variable=TEST_RESULTS_FILE]$test_results_file"
    - displayName: Set Script Module Directory
      script: |-
        if [ -n "${TEST_MODULES_DIR}" ]; then
            test_modules_directory=$(Pipeline.Workspace)/s/${TEST_MODULES_DIR}
        else
            test_modules_directory=$(Pipeline.Workspace)/s/modules/bash
        fi
        echo "Script modules directory: $test_modules_directory"
        echo "##vso[task.setvariable variable=TEST_MODULES_DIR]$test_modules_directory"
      env:
        TEST_MODULES_DIR: ''
    - displayName: Get login credentials
      task: AzureCLI@2
      inputs:
        azureSubscription: null
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |-
          echo "##vso[task.setvariable variable=SP_CLIENT_ID;issecret=true]$servicePrincipalId"
          echo "##vso[task.setvariable variable=SP_ID_TOKEN;issecret=true]$idToken"
          echo "##vso[task.setvariable variable=TENANT_ID;issecret=true]$tenantId"
        addSpnToEnvironment: 'true'
    - displayName: Azure Login
      script: |-
        set -eu

        echo "login to Azure in $REGION"
        az login --service-principal --tenant $(TENANT_ID) -u $(SP_CLIENT_ID) --federated-token $(SP_ID_TOKEN) --allow-no-subscriptions
        az account set --subscription "$AZURE_SP_SUBSCRIPTION_ID"
        az config set defaults.location="$REGION"
        az account show
      env:
        REGION: eastus2
        AZURE_SP_SUBSCRIPTION_ID: null
    - displayName: Check Dependencies
      script: |-
        python3 --version && pip3 --version
        jq --version
    - displayName: Install Dependencies
      script: |-
        set -e
        if [ -f "$(Pipeline.Workspace)/s/modules/python/requirements.txt" ]; then
            pip3 install -r $(Pipeline.Workspace)/s/modules/python/requirements.txt
        fi
        sudo apt-get -y install bc
    - displayName: Set Terraform  Working Directory
      script: |-
        if [ -n "$MODULES_DIR" ]; then
            terraform_working_directory=$(Pipeline.Workspace)/s/$MODULES_DIR
        else
            terraform_working_directory=$(Pipeline.Workspace)/s/modules/terraform/$CLOUD
        fi
        echo "##vso[task.setvariable variable=TERRAFORM_WORKING_DIRECTORY]$terraform_working_directory"
        echo "Terraform Working Directory: $terraform_working_directory
      env:
        CLOUD: azure
        MODULES_DIR: ''
    - displayName: Set Terraform Input File
      script: |-
        set -eu

        regional_config=$(jq -n '{}')

        terraform_file_config=$(echo "${{ convertToJson(parameters.input_file_mapping) }}" |             sed -E 's/([a-zA-Z0-9_-]+):/"\1":/g; s/: ([^",]+)/: "\1"/g' | jq -r '.[]')

        multi_region=$(echo "$REGIONS" | jq -r 'if length > 1 then "true" else "false" end')
        echo "##vso[task.setvariable variable=MULTI_REGION]$multi_region"

        for region in $(echo "$REGIONS" | jq -r '.[]'); do
            if [ -n "$terraform_file_config" ]; then
                # Use the regional input file path from the mapping
                regional_input_file_path=$(echo "$terraform_file_config" | jq -r --arg region "$region" '.[$region]')
                terraform_input_file=$(Pipeline.Workspace)/s/${regional_input_file_path}
            elif [ "$multi_region" = "false" ]; then
                # Use the default input file for single-region deployments
                terraform_input_file=$(Pipeline.Workspace)/s/scenarios/$SCENARIO_TYPE/$SCENARIO_NAME/terraform-inputs/${CLOUD}.tfvars
            else
                # Use the region-specific input file for multi-region deployments
                terraform_input_file=$(Pipeline.Workspace)/s/scenarios/$SCENARIO_TYPE/$SCENARIO_NAME/terraform-inputs/${CLOUD}-${region}.tfvars
            fi

            # Add the file path to the regional configuration
            regional_config=$(echo $regional_config | jq --arg region $region --arg file_path $terraform_input_file                 '. + {($region): {"TERRAFORM_INPUT_FILE" : $file_path}}')
        done

        regional_config_str=$(echo $regional_config | jq -c .)
        echo "##vso[task.setvariable variable=REGIONAL_CONFIG]$regional_config_str"
      condition: ne(variables['SKIP_RESOURCE_MANAGEMENT'], 'true')
      env:
        CLOUD: azure
        REGIONS: eastus2
    - displayName: Set User Data Path
      script: |-
        if [ -v "$USER_DATA_PATH" ]; then
            terraform_user_data_path=$(Pipeline.Workspace)/s/$USER_DATA_PATH
        else
            terraform_user_data_path=$(Pipeline.Workspace)/s/scenarios/$SCENARIO_TYPE/$SCENARIO_NAME/scripts/user_data
        fi
        echo $terraform_user_data_path
        echo "##vso[task.setvariable variable=TERRAFORM_USER_DATA_PATH]$terraform_user_data_path"
      env:
        USER_DATA_PATH: ''
    - displayName: Set Terraform Input Variables
      script: |-
        set -e

                if [[ "${DEBUG,,}" =~ "true" ]]; then
                  set -x
                fi

                SYSTEM_NODE_POOL=${SYSTEM_NODE_POOL:-null}
                USER_NODE_POOL=${USER_NODE_POOL:-null}

                if [ -z "$(AKS_CLI_CUSTOM_HEADERS)" ]; then
                  AKS_CUSTOM_HEADERS='[]'
                else
                  IFS=', ' read -r -a aks_custom_headers_array <<< "$(AKS_CLI_CUSTOM_HEADERS)"
                  AKS_CUSTOM_HEADERS=$(printf '%s
        ' "${aks_custom_headers_array[@]}" | jq -R . | jq -s .)
                fi

                regional_config=$REGIONAL_CONFIG
                for REGION in $(echo "$REGIONS" | jq -r '.[]'); do
                  if [ -z "$INPUT_VARIABLES" ]; then
                    echo "Set input variables for region $REGION"
                    INPUT_VARIABLES=$(jq -n                   --arg run_id $RUN_ID                   --arg region $REGION                   --arg aks_sku_tier "$SKU_TIER"                   --arg aks_kubernetes_version "$KUBERNETES_VERSION"                   --arg aks_network_policy "$NETWORK_POLICY"                   --arg aks_network_dataplane "$NETWORK_DATAPLANE"                   --arg k8s_machine_type "$K8S_MACHINE_TYPE"                   --arg k8s_os_disk_type "$K8S_OS_DISK_TYPE"                   --argjson aks_custom_headers "$AKS_CUSTOM_HEADERS"                   --argjson aks_cli_system_node_pool "$SYSTEM_NODE_POOL"                   --argjson aks_cli_user_node_pool "$USER_NODE_POOL"                   '{
                            run_id: $run_id,
                            region: $region,
                            aks_sku_tier: $aks_sku_tier,
                            aks_kubernetes_version: $aks_kubernetes_version,
                            aks_network_policy: $aks_network_policy,
                            aks_network_dataplane: $aks_network_dataplane,
                            k8s_machine_type: $k8s_machine_type,
                            k8s_os_disk_type: $k8s_os_disk_type,
                            aks_custom_headers: $aks_custom_headers,
                            aks_cli_system_node_pool: $aks_cli_system_node_pool,
                            aks_cli_user_node_pool: $aks_cli_user_node_pool
                          }' | jq 'with_entries(select(.value != null and .value != ""))')
                  fi
                  input_variables_str=$(echo $INPUT_VARIABLES | jq -c .)
                  echo "Input variables: $input_variables_str"
                  regional_config=$(echo "$regional_config" | jq --arg region "$REGION" --arg input_variable "$input_variables_str"               '.[$region].TERRAFORM_INPUT_VARIABLES += $input_variable')
                  echo "Regional config: $regional_config"
                  INPUT_VARIABLES=""
                done
                regional_config_str=$(echo $regional_config | jq -c .)
                echo "Final regional config: $regional_config_str"
                echo "##vso[task.setvariable variable=TERRAFORM_REGIONAL_CONFIG]$regional_config_str"
      condition: ne(variables['SKIP_RESOURCE_MANAGEMENT'], 'true')
      env:
        CLOUD: azure
        REGIONS: eastus2
        RUN_ID: $(RUN_ID)
        INPUT_VARIABLES: {}
        DEBUG: $(System.Debug)
        SKU_TIER: $(SKU_TIER)
        KUBERNETES_VERSION: $(KUBERNETES_VERSION)
        NETWORK_POLICY: $(NETWORK_POLICY)
        NETWORK_DATAPLANE: $(NETWORK_DATAPLANE)
        K8S_MACHINE_TYPE: $(K8S_MACHINE_TYPE)
        K8S_OS_DISK_TYPE: $(K8S_OS_DISK_TYPE)
        AKS_CLI_CUSTOM_HEADERS: $(AKS_CLI_CUSTOM_HEADERS)
        SYSTEM_NODE_POOL: $(SYSTEM_NODE_POOL)
        USER_NODE_POOL: $(USER_NODE_POOL)
    - displayName: Get Deletion Due Time and Owner
      script: |-
        set -e

        terraform_input_file=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_FILE')

        deletion_delay=$(grep 'deletion_delay' "$terraform_input_file" | awk -F'=' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); gsub(/[^0-9]/, "", $2); print $2}')
        echo "Deletion Delay: $deletion_delay hr"

        deletion_due_time=$(date -u -d "+${deletion_delay} hour" +'%Y-%m-%dT%H:%M:%SZ')
        echo "Deletion Due Time: $deletion_due_time"
        echo "##vso[task.setvariable variable=DELETION_DUE_TIME]$deletion_due_time"

        owner=$(grep 'owner' "$terraform_input_file" | awk -F'=' '{gsub(/^[ \t]+|[ \t]+$/, "", $2); print $2}' | sed 's/^"//;s/"$//')
        echo "Owner: $owner"
        echo "##vso[task.setvariable variable=OWNER]$owner"
      condition: ne(variables['SKIP_RESOURCE_MANAGEMENT'], 'true')
      env:
        region: eastus2
    - displayName: Create Resource Group
      script: |-
        set -eu
        echo "Create resource group $RUN_ID in region $region"
        az group create --name $RUN_ID --location $region           --tags "run_id=$RUN_ID" "scenario=${SCENARIO_TYPE}-${SCENARIO_NAME}" "owner=${OWNER}" "creation_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" "deletion_due_time=${DELETION_DUE_TIME}" "SkipAKSCluster=1"
      condition: and(eq('azure', 'azure'), ne(variables['SKIP_RESOURCE_MANAGEMENT'],
        'true'))
      env:
        region: eastus2
    - displayName: Run Terraform Version Command
      script: |-
        set -e

        # Navigate to the Terraform working directory
        cd $TERRAFORM_WORKING_DIRECTORY

        # Handle apply or destroy commands
        if [[ "version" == "apply" || "version" == "destroy" ]]; then
          for region in $(echo "$REGIONS" | jq -r '.[]'); do
            echo "Processing region: $region"

            # Select or create Terraform workspace
            if terraform workspace list | grep -q "$region"; then
              terraform workspace select $region
            else
              terraform workspace new $region
              terraform workspace select $region
            fi

            # Retrieve input file and variables
            terraform_input_file=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_FILE')
            terraform_input_variables=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_VARIABLES')

            # Run Terraform command
            set +e
            terraform version --auto-approve  -var-file $terraform_input_file -var json_input="$terraform_input_variables"
            exit_code=$?
            set -e

            # Handle errors
            if [[ $exit_code -ne 0 ]]; then
              echo "Terraform version failed for region: $region"
              if [[ "version" == "apply" && "$CLOUD" == "azure" ]]; then
                echo "Deleting resources and removing state file before retrying"
                ids=$(az resource list --location $region --resource-group $RUN_ID --query [*].id -o tsv)
                az resource delete --ids $ids --verbose
                rm -r terraform.tfstate.d/$region
              elif [[ "version" == "destroy" && "$CLOUD" == "aws" ]]; then
                echo "Cleaning up AWS resources before retrying"
                # Detach and delete network interfaces
                subnet_ids=$(aws ec2 describe-subnets --query "Subnets[?Tags[?Key=='run_id' && Value=='$RUN_ID']].SubnetId" --output text)
                for subnet_id in $subnet_ids; do
                  echo "Detaching network interfaces for subnet: $subnet_id"
                  network_interfaces=$(aws ec2 describe-network-interfaces --filters Name=subnet-id,Values=$subnet_id --query "NetworkInterfaces[].NetworkInterfaceId" --output text)
                  for network_interface in $network_interfaces; do
                    aws ec2 delete-network-interface --network-interface-id $network_interface || echo "Failed to delete network interface: $network_interface"
                  done
                done

                # Delete security groups
                vpc_id=$(aws ec2 describe-vpcs --query "Vpcs[?Tags[?Key=='run_id' && Value=='$RUN_ID']].VpcId" --output text)
                security_group_ids=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=$vpc_id --query "SecurityGroups[].GroupId" --output text)
                for security_group_id in $security_group_ids; do
                  aws ec2 delete-security-group --group-id $security_group_id || echo "Failed to delete security group: $security_group_id"
                done
              fi
              exit 1
            fi
          done
        else
          # Run other Terraform commands
          terraform version
        fi
      condition: ne(variables['SKIP_RESOURCE_MANAGEMENT'], 'true')
      retryCountOnTaskFailure: 3
      env:
        REGIONS: ''
        CLOUD: ''
        ARM_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
    - displayName: Run Terraform Init Command
      script: |-
        set -e

        # Navigate to the Terraform working directory
        cd $TERRAFORM_WORKING_DIRECTORY

        # Handle apply or destroy commands
        if [[ "init" == "apply" || "init" == "destroy" ]]; then
          for region in $(echo "$REGIONS" | jq -r '.[]'); do
            echo "Processing region: $region"

            # Select or create Terraform workspace
            if terraform workspace list | grep -q "$region"; then
              terraform workspace select $region
            else
              terraform workspace new $region
              terraform workspace select $region
            fi

            # Retrieve input file and variables
            terraform_input_file=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_FILE')
            terraform_input_variables=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_VARIABLES')

            # Run Terraform command
            set +e
            terraform init --auto-approve  -var-file $terraform_input_file -var json_input="$terraform_input_variables"
            exit_code=$?
            set -e

            # Handle errors
            if [[ $exit_code -ne 0 ]]; then
              echo "Terraform init failed for region: $region"
              if [[ "init" == "apply" && "$CLOUD" == "azure" ]]; then
                echo "Deleting resources and removing state file before retrying"
                ids=$(az resource list --location $region --resource-group $RUN_ID --query [*].id -o tsv)
                az resource delete --ids $ids --verbose
                rm -r terraform.tfstate.d/$region
              elif [[ "init" == "destroy" && "$CLOUD" == "aws" ]]; then
                echo "Cleaning up AWS resources before retrying"
                # Detach and delete network interfaces
                subnet_ids=$(aws ec2 describe-subnets --query "Subnets[?Tags[?Key=='run_id' && Value=='$RUN_ID']].SubnetId" --output text)
                for subnet_id in $subnet_ids; do
                  echo "Detaching network interfaces for subnet: $subnet_id"
                  network_interfaces=$(aws ec2 describe-network-interfaces --filters Name=subnet-id,Values=$subnet_id --query "NetworkInterfaces[].NetworkInterfaceId" --output text)
                  for network_interface in $network_interfaces; do
                    aws ec2 delete-network-interface --network-interface-id $network_interface || echo "Failed to delete network interface: $network_interface"
                  done
                done

                # Delete security groups
                vpc_id=$(aws ec2 describe-vpcs --query "Vpcs[?Tags[?Key=='run_id' && Value=='$RUN_ID']].VpcId" --output text)
                security_group_ids=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=$vpc_id --query "SecurityGroups[].GroupId" --output text)
                for security_group_id in $security_group_ids; do
                  aws ec2 delete-security-group --group-id $security_group_id || echo "Failed to delete security group: $security_group_id"
                done
              fi
              exit 1
            fi
          done
        else
          # Run other Terraform commands
          terraform init
        fi
      condition: ne(variables['SKIP_RESOURCE_MANAGEMENT'], 'true')
      retryCountOnTaskFailure: 3
      env:
        REGIONS: ''
        CLOUD: ''
        ARM_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
    - displayName: Run Terraform Apply Command
      script: |-
        set -e

        # Navigate to the Terraform working directory
        cd $TERRAFORM_WORKING_DIRECTORY

        # Handle apply or destroy commands
        if [[ "apply" == "apply" || "apply" == "destroy" ]]; then
          for region in $(echo "$REGIONS" | jq -r '.[]'); do
            echo "Processing region: $region"

            # Select or create Terraform workspace
            if terraform workspace list | grep -q "$region"; then
              terraform workspace select $region
            else
              terraform workspace new $region
              terraform workspace select $region
            fi

            # Retrieve input file and variables
            terraform_input_file=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_FILE')
            terraform_input_variables=$(echo $TERRAFORM_REGIONAL_CONFIG | jq -r --arg region "$region" '.[$region].TERRAFORM_INPUT_VARIABLES')

            # Run Terraform command
            set +e
            terraform apply --auto-approve  -var-file $terraform_input_file -var json_input="$terraform_input_variables"
            exit_code=$?
            set -e

            # Handle errors
            if [[ $exit_code -ne 0 ]]; then
              echo "Terraform apply failed for region: $region"
              if [[ "apply" == "apply" && "$CLOUD" == "azure" ]]; then
                echo "Deleting resources and removing state file before retrying"
                ids=$(az resource list --location $region --resource-group $RUN_ID --query [*].id -o tsv)
                az resource delete --ids $ids --verbose
                rm -r terraform.tfstate.d/$region
              elif [[ "apply" == "destroy" && "$CLOUD" == "aws" ]]; then
                echo "Cleaning up AWS resources before retrying"
                # Detach and delete network interfaces
                subnet_ids=$(aws ec2 describe-subnets --query "Subnets[?Tags[?Key=='run_id' && Value=='$RUN_ID']].SubnetId" --output text)
                for subnet_id in $subnet_ids; do
                  echo "Detaching network interfaces for subnet: $subnet_id"
                  network_interfaces=$(aws ec2 describe-network-interfaces --filters Name=subnet-id,Values=$subnet_id --query "NetworkInterfaces[].NetworkInterfaceId" --output text)
                  for network_interface in $network_interfaces; do
                    aws ec2 delete-network-interface --network-interface-id $network_interface || echo "Failed to delete network interface: $network_interface"
                  done
                done

                # Delete security groups
                vpc_id=$(aws ec2 describe-vpcs --query "Vpcs[?Tags[?Key=='run_id' && Value=='$RUN_ID']].VpcId" --output text)
                security_group_ids=$(aws ec2 describe-security-groups --filters Name=vpc-id,Values=$vpc_id --query "SecurityGroups[].GroupId" --output text)
                for security_group_id in $security_group_ids; do
                  aws ec2 delete-security-group --group-id $security_group_id || echo "Failed to delete security group: $security_group_id"
                done
              fi
              exit 1
            fi
          done
        else
          # Run other Terraform commands
          terraform apply
        fi
      condition: ne(variables['SKIP_RESOURCE_MANAGEMENT'], 'true')
      retryCountOnTaskFailure: 3
      env:
        REGIONS: eastus2
        CLOUD: azure
        ARM_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)
  - job: validate
    displayName: Validate resources
    steps: []
    dependsOn:
    - setup
  - job: run
    displayName: Run the benchmark
    steps: []
    dependsOn:
    - validate
  - job: tear down
    displayName: Tear down resources
    steps: []
    dependsOn:
    - run
